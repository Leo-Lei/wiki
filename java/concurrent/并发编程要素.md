---
layout: post
title: 并发编程要素
date: 2015-08-18 16:40:00
tags:
- Java
categories: Java
---

# 共享性
数据共享性是线程安全的主要原因之一。如果所有的数据只是在线程内有效，那就不存在线程安全性问题，这也是我们在编程的时候经常不需要考虑线程安全的主要原因之一。但是，在多线程编程中，数据共享是不可避免的。最典型的场景是数据库中的数据，为了保证数据的一致性，我们通常需要共享同一个数据库中数据。    
下面是一个简单的实例来演示在多线程环境下，对共享数据进行操作时，容易出现各种意想不到的结果。        
```java
public class TestClass {
    private static int count = 0;

    public static void main(String[] args) throws Exception {
        for (int i = 0; i < 100; i++){
            new Thread(() -> {
                Thread.sleep(50);
                count++;
            }).start();
        }

        Thread.sleep(1000 * 5);
        System.out.println(count);
    }
}
```
上面实例中，有100个线程，每个线程对count加1。正常情况下应该输出100。但实际结果并不是的，可能是88，90或其他，可能是小于100的。

# 互斥性
同时只允许一个访问者对其进行访问。Java提供了多种机制来保证互斥性，最简单的方式是使用Synchronized关键字。

# 原子性
原子性就是指对数据的操作是一个独立的、不可分割的整体。换句话说，就是一次操作，是一个连续不可中断的过程，数据不会执行的一半的时候被其他线程所修改。保证原子性的最简单方式是操作系统指令，就是说如果一次操作对应一条操作系统指令，这样肯定可以能保证原子性。但是很多操作不能通过一条指令就完成。例如，对long类型的运算，很多系统就需要分成多条指令分别对高位和低位进行操作才能完成。还比如，我们经常使用的整数 i++ 的操作，其实需要分成三个步骤：
1. 读取整数 i 的值；
2. 对 i 进行加一操作；
3. 将结果写回内存。
```text
  线程1   +----------+     +----------+     +-----------+
-------->| 读取i=1   |---->| i=i+1    |---->| 存储i=2    |
         +----------+     +----------+     +-----------+

       线程2    +----------+     +----------+     +-----------+
      -------->| 读取i=1   |---->| i=i+1    |---->| 存储i=2   |
               +----------+     +----------+     +-----------+
```
这也是代码段一执行的结果为什么不正确的原因。对于这种组合操作，要保证原子性，最常见的方式是加锁，如Java中的Synchronized或Lock都可以实现，代码段二就是通过Synchronized实现的。除了锁以外，还有一种方式就是CAS（Compare And Swap），即修改数据之前先比较与之前读取到的值是否一致，如果一致，则进行修改，如果不一致则重新执行，这也是乐观锁的实现原理。不过CAS在某些场景下不一定有效，比如另一线程先修改了某个值，然后再改回原来值，这种情况下，CAS是无法判断的。




