---
layout: post
title: Java并发编程-核心理论
date: 2015-08-18 16:40:00
tags:
- Java
categories: Java
---

# 共享性
数据共享性是线程安全的主要原因之一。如果所有的数据只是在线程内有效，那就不存在线程安全性问题，这也是我们在编程的时候经常不需要考虑线程安全的主要原因之一。但是，在多线程编程中，数据共享是不可避免的。最典型的场景是数据库中的数据，为了保证数据的一致性，我们通常需要共享同一个数据库中数据。    
下面是一个简单的实例来演示在多线程环境下，对共享数据进行操作时，容易出现各种意想不到的结果。        
```java
public class TestClass {
    private static int count = 0;

    public static void main(String[] args) throws Exception {
        for (int i = 0; i < 100; i++){
            new Thread(() -> {
                Thread.sleep(50);
                count++;
            }).start();
        }

        Thread.sleep(1000 * 5);
        System.out.println(count);
    }
}
```
上面实例中，有100个线程，每个线程对count加1。正常情况下应该输出100。但实际结果并不是的，可能是88，90或其他，可能是小于100的。

# 互斥性
同时只允许一个访问者对其进行访问。Java提供了多种机制来保证互斥性，最简单的方式是使用Synchronized关键字。

# 原子性
原子性就是指对数据的操作是一个独立的、不可分割的整体。换句话说，就是一次操作，是一个连续不可中断的过程，数据不会执行的一半的时候被其他线程所修改。保证原子性的最简单方式是操作系统指令，就是说如果一次操作对应一条操作系统指令，这样肯定可以能保证原子性。但是很多操作不能通过一条指令就完成。例如，对long类型的运算，很多系统就需要分成多条指令分别对高位和低位进行操作才能完成。还比如，我们经常使用的整数 i++ 的操作，其实需要分成三个步骤：
1. 读取整数 i 的值；
2. 对 i 进行加一操作；
3. 将结果写回内存。
```text
  线程1   +----------+     +----------+     +-----------+
-------->| 读取i=1   |---->| i=i+1    |---->| 存储i=2    |
         +----------+     +----------+     +-----------+

       线程2    +----------+     +----------+     +-----------+
      -------->| 读取i=1   |---->| i=i+1    |---->| 存储i=2   |
               +----------+     +----------+     +-----------+
```
这也是代码段一执行的结果为什么不正确的原因。对于这种组合操作，要保证原子性，最常见的方式是加锁，如Java中的Synchronized或Lock都可以实现，代码段二就是通过Synchronized实现的。除了锁以外，还有一种方式就是CAS（Compare And Swap），即修改数据之前先比较与之前读取到的值是否一致，如果一致，则进行修改，如果不一致则重新执行，这也是乐观锁的实现原理。不过CAS在某些场景下不一定有效，比如另一线程先修改了某个值，然后再改回原来值，这种情况下，CAS是无法判断的。


# 可见性
要理解可见性，需要先对JVM的内存模型有一定的了解，JVM的内存模型与操作系统类似，如图所示：
```text
+----------------+               +----------------+
|      线程一     |               |      线程二     |
+---------------+                +----------------+
        |                                  |
        |                                  |
+-----------------+              +-------------------+
|      CPU        |              |         CPU       |
|   线程一工作内存  |              |    线程二工作内存    |  
|                 |              |                   |
|    共享变量副本   |              |    共享变量副本     |   
+-----------------+              +-------------------+
         |                                  |
         |                                  |
+------------------------------------------------------+
|                                                      |
|      共享变量         主内存             共享变量        |
|                                                      |
+-------------------------------------------------------
```
从这个图中我们可以看出，每个线程都有一个自己的工作内存（相当于CPU高级缓冲区，这么做的目的还是在于进一步缩小存储系统与CPU之间速度的差异，提高性能），对于共享变量，线程每次读取的是工作内存中共享变量的副本，写入的时候也直接修改工作内存中副本的值，然后在某个时间点上再将工作内存与主内存中的值进行同步。这样导致的问题是，如果线程1对某个变量进行了修改，线程2却有可能看不到线程1对共享变量所做的修改。
```java
public class TestClass2 {
    private static boolean ready;
    private static int number;

    private static class ReadThread extends Thread{
        @Override
        public void run() {
            Thread.sleep(50);
            if (!ready){
                System.out.println(ready);
            }
            System.out.println(number);
        }
    }

    private static class WriteThread extends Thread{
        @Override
        public void run() {
            Thread.sleep(50);
            number = 100;
            ready = true;
        }
    }

    public static void main(String[] args) {
        new WriteThread().start();
        new ReadThread().start();
    }
}
```
上面这段代码，多运行几次，会出现比较意外的输出。比如，输出了
```text
true
100
```
这个结果可能是由于可见性造成的。当写线程设置ready=true后，读线程看不到修改后的结果。所以会打印false。
或者
```text
false
100
```
这个结果，执行if(!ready)时没有读取到写线程的结果，但执行System.out.println(ready)时读取到了写线程的结果。不过这个结果也可能是线程的交替执行造成的。    
Java中可通过Synchronized或Volatile来保证可见性。


# 有序性
为了提高性能，编译器和处理器可能会对指令做重排序。重排序可分为3种：
1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
2. 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。
Java中也可以通过Synchronized或Volatile来保证顺序性
