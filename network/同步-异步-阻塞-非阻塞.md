---
layout: post
title: 同步-异步-阻塞-非阻塞
date: 2017-05-20 14:00:00
tags:
- Java
categories: Java
---

对于同步，异步，阻塞，非阻塞，不同的人有不同的理解。
本篇文章参考Unix操作系统中定义的如下五个IO模型：
* blocking IO
* nonblocking IO
* IO multiplexing
* signal driven
* asynchronous IO

对于一个网络IO操作，会涉及到两个角色:
* 一个是发起IO操作的进程，也就是我们的应用程序。
* 另一个是操作系统内核kernel。
当发生一个read操作后，会经历两个阶段：
1. 等待数据准备好
2. 将数据从内核拷贝到进程中
不同的网络模型，这两个阶段发生的事情是不一样的。

为了避免歧义，作如下的定义:
1. 应用进程: 非操作系统进程。及我们自己运行的应用程序的进程。
2. kernel：操作系统内核

## blocking IO
Linux中，默认情况下，所有的socket都是blocking的。一个典型的read操作的流程大概是这样的:
1. 当应用进程调用了read操作，kernel就开始了IO的第一个阶段：准备数据。
2. 对于网络IO，很多时候数据在一开始的时候还没有到达。比如没有收到一个完整的UDP包。
3. 如果数据没有准备好，kernel就要等待足够的数据到来。
4. 用户进程这边，整个进程会被阻塞。
5. 当kernel准备好数据，kernel会将数据从kernel中拷贝到应用内存。然后返回结果
6. 用户进程解除block状态，重新运行起来
所以blocking IO的特点就是IO执行的这两个阶段都被block了。

## non-blocking IO
1. 如果kernel中的数据没有准备好，直接返回一个error，不会block应用进程
2. 应用进程判断结果是一个error时，就知道数据还没有准备好，可以选择等待一段时间再次发送raad操作。
3. 应用进程不断的尝试
4. 如果kernel中的数据准备好了，kernel会将数据拷贝到应用进程的内存中。
所以，应用进程其实是不断的主动询问kernel数据好了没有

## IO multiplexing(IO多路复用)
支持IO多路复用的系统调用有：select，epoll等。select和epoll的好处在于单个process就可以同时处理多个网络连接的IO。基本原理是select，epoll会不断的轮询所负责的所有socket，当某个socket数据到达时，就通知用户进程





