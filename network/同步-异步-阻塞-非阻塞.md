---
layout: post
title: 同步-异步-阻塞-非阻塞
date: 2017-05-20 14:00:00
tags:
- Java
categories: Java
---

对于同步，异步，阻塞，非阻塞，不同的人有不同的理解。
本篇文章参考Unix操作系统中定义的如下五个IO模型：
* blocking IO
* nonblocking IO
* IO multiplexing
* signal driven
* asynchronous IO

对于一个网络IO操作，会涉及到两个角色:
* 一个是发起IO操作的进程，也就是我们的应用程序。
* 另一个是操作系统内核kernel。
当发生一个read操作后，会经历两个阶段：
1. 等待数据准备好
2. 将数据从内核拷贝到进程中
不同的网络模型，这两个阶段发生的事情是不一样的。

为了避免歧义，作如下的定义:
1. 应用进程: 非操作系统进程。及我们自己运行的应用程序的进程。
2. kernel：操作系统内核

## blocking IO
Linux中，默认情况下，所有的socket都是blocking的。一个典型的read操作的流程大概是这样的:
1. 当应用进程调用了read操作，kernel就开始了IO的第一个阶段：准备数据。
2. 对于网络IO，很多时候数据在一开始的时候还没有到达。比如没有收到一个完整的UDP包。
3. 如果数据没有准备好，kernel就要等待足够的数据到来。
4. 用户进程这边，整个进程会被阻塞。
5. 当kernel准备好数据，kernel会将数据从kernel中拷贝到应用内存。然后返回结果
6. 用户进程解除block状态，重新运行起来
所以blocking IO的特点就是IO执行的这两个阶段都被block了。

## non-blocking IO
1. 如果kernel中的数据没有准备好，直接返回一个error，不会block应用进程
2. 应用进程判断结果是一个error时，就知道数据还没有准备好，可以选择等待一段时间再次发送raad操作。
3. 应用进程不断的尝试
4. 如果kernel中的数据准备好了，kernel会将数据拷贝到应用进程的内存中。
所以，应用进程其实是不断的主动询问kernel数据好了没有

## IO multiplexing(IO多路复用)
支持IO多路复用的系统调用有：select，epoll等。select和epoll的好处在于单个process就可以同时处理多个网络连接的IO。基本原理是select，epoll会不断的轮询所负责的所有socket，当某个socket数据到达时,用户进程就可以读取数据了。

## asynchronous  IO
异步IO。用户进程发起read操作后，立即返回，可以去做别的事情了。kernel收到异步的read之后，会立即返回。所以不会对用户进程产生任何block。然后kernel等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成后，kernel会给用户进程发送一个signal，告诉它read操作完成了。



```text
|   blocking    |   non-blocking  | IO multiplexing  |   asynchronaous IO   |
| ------------- | ----------------| ---------------- |  ------------------- |   ----
|   initiate    |     check       |       check      |        initiate      |       |
|       |       |     check       |         |        |                      |       |
|       |       |     check       |         |        |                      |       |
|       |       |     check       |         |        |                      |       |
|       |       |     check       |         |        |                      |        >   wait for data
|       |       |     check       |         |        |                      |       |
|       |       |     check       |         |        |                      |       |
|       |       |     check       |         |        |                      |       |
|       |       |     check       |         V        |                      |       |
|       |       |     check       |       ready      |                      |   -----
|       |       |       |         |     initiate     |                      |       |
|       |       |       |         |         |        |                      |       |
|       |       |       |         |         |        |                      |       |
|       |       |       |         |         |        |                      |       |
|       |       |       |         |         |        |                      |        >  copy data from 
|       |       |       |         |         |        |                      |       |   kernel to user
|       |       |       |         |         |        |                      |       |
|       |       |       |         |         |        |                      |       |
|       V       |       V         |         V        |                      |       |
|    complete   |    complete     |     complete     |    notification      |       |
| ------------------------------------------------------------------------- |   ----

|                                                    |                      |
 ------------------------v--------------------------   ---------v----------
            1st phase handled differently;   
            2nd phase handled the same
            (blocked in call to recvfrom)

```


从上面的图可以看到，non-blocking和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它任然要求进程主动的
去check，而且当数据准备好之后，也需要用户进程调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则不同。用户进程不需要去检查IO数据是不是好了，也不需要主动的去拷贝数据。


最后举个例子来说明这几个IO模型：
有四个人在钓鱼
A用的是老式的鱼竿，他一直守着，等到鱼上钩了再拉杆
B用的也是老式鱼竿，他一遍钓鱼一边看书。隔会儿看看鱼有没有上钩，如果上钩了，就拉杆。
C用的也是老式鱼竿，他同时放好几根鱼竿，然后守在旁边。一旦有那个鱼钩有鱼上钩了，就将对应的鱼竿拉起来。
D用的是新式的鱼竿，有鱼上钩时，就发出声音提醒。D可以一边看书一边钓鱼，等有鱼上钩了，鱼竿发出声音，D就将鱼竿拉起来。



