---
layout: post
title: Distributed Transaction
date: 2017-04-11 13:05:00
tags:
- Java
categories: Java
---

# 分布式事务的例子
从支付宝向余额宝转账。
可能会涉及到两张表：
* 支付宝账户表：A (id,userId,amount)
* 余额宝账户表：B (id,userId,amount)

# 本地事务
使用一个数据库事务来实现
```sql
Begin transaction
         update A set amount=amount-10000 where userId=1;
         update B set amount=amount+10000 where userId=1;
End transaction
commit;
```
只适合于系统规模小，数据库表都在一个数据库实例上。如果支付宝和余额宝的数据分布在两个系统中，本地事务就失效了。
# 分布式事务-两阶段提交
分为协调器和若干事务执行者两种角色。协调器可以和事务执行者在同一台机器上。
![两阶段提交](https://images0.cnblogs.com/blog2015/522490/201508/091642197846523.png)
1. 应用(client)发起一个请求到事务协调器
2. 事务协调器将prepare消息写到本地日志，之后向所有的事务执行者发起prepare消息。以支付宝转账到余额宝为例，事务协调器发送给A的prepare消息是通知支付宝数据库扣款，事务协调器发送给B的prepare消息是通知余额宝数据库响应增加。
3. 事务执行者收到prepare消息后，执行具体本机事务，但不会commit，如果成功给事务协调器返回一个yes，不成功返回no。同理，返回前，都要把要返回的消息写到日志中，当做凭证。
4. 事务协调器收集所有事务执行器的返回结果。如果所有执行器都返回yes，那么给所有事务执行者发送commit消息。执行器收到commit消息后执行本地事务的commit操作。如果有任何一个执行器返回no，那么给所有执行器发送abort消息，执行器收到abort消息后执行事务回滚操作。

注意：事务协调器和事务执行者，把发送的或收到的消息都先写日志，主要是为了故障后恢复用。如某一事务执行者从故障中恢复后，先检查本机的日志，如果已收到commit，则提交。如果收到abort消息，则回滚。如果是发送的yes，则向事务协调者询问一下，确定下一步。如果什么都没有，则很可能在prepare阶段事务执行者就崩溃了，需要回滚。

缺点：性能太差，不适合高并发的系统。        
1) 两阶段提交涉及多次节点间的网络通信，通信时间太长
2) 事务时间变长了，锁定的资源的时间也变长了，资源等待时间变长

# 补偿




# 使用消息队列来避免分布式事务
如果仔细观察生活的话，生活的很多场景已经给了我们提示。

比如在北京很有名的姚记炒肝点了炒肝并付了钱后，他们并不会直接把你点的炒肝给你，往往是给你一张小票，然后让你拿着小票到出货区排队去取。为什么他们要将付钱和取货两个动作分开呢？原因很多，其中一个很重要的原因是为了使他们接待能力增强（并发量更高）。

还是回到我们的问题，只要这张小票在，你最终是能拿到炒肝的。同理转账服务也是如此，当支付宝账户扣除1万后，我们只要生成一个凭证（消息）即可，这个凭证（消息）上写着“让余额宝账户增加 1万”，只要这个凭证（消息）能可靠保存，我们最终是可以拿着这个凭证（消息）让余额宝账户增加1万的，即我们能依靠这个凭证（消息）完成最终一致性。















